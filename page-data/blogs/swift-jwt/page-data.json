{"componentChunkName":"component---src-templates-blogs-js","path":"/blogs/swift-jwt","result":{"data":{"blog":{"html":"<p>Authorisation is an important part of any web service, and JSON Web Tokens, or JWTs, have risen in popularity in recent years and serve as an alternative to cookies and OAuth tokens. Swift-JWT is a new, powerful Swift library for creating, signing, and verifying JWTs, and it works seamlessly with Kitura.</p>\n<h2 id=\"introduction-to-json-web-tokens\"><a href=\"#introduction-to-json-web-tokens\" aria-label=\"introduction to json web tokens permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introduction to JSON Web Tokens</h2>\n<p>As a brief introduction to JWTs for those who have never come across them before, they are a small JSON payload consisting of a Header object, a Claims object and a signature.</p>\n<p>The Header object describes the JWT type and the algorithm used. It is then Base64 Encoded.</p>\n<p>The Claims object has fields that are either Registered, Public or Private. A full list of the Registered claims <a href=\"https://tools.ietf.org/html/rfc7519#section-4.1\">can be found here</a>. Registered claims tend to be interoperable and predefined, whereas Public and Private claims are created by the developer implementing the JWT. Public claims should be used according to the IANA JWT Registry to avoid namespace collisions. Finally, Private claims would be those specific to your application, and are not always needed. An example could be a field marking JWT bearer as an administrator. This is then also Base64Encoded and appended to the Header using a single period (.).</p>\n<p>Lastly, a signature is generated by using a combination of the encoded header, claims, a secret and is then signed using the algorithm specified in the Headers ‘alg’ field. This is appended to the end of the JWT, forming three parts separated by periods. The signature can be left blank if the JWT requires no authentication. For more on JWTs, I recommend the <a href=\"https://jwt.io/introduction/\">JWT.io website</a>.</p>\n<p>Now may be a good time to point out that this blog will focus on signed JWTs, not encrypted ones. JSON Web Signature (JWS) and JSON Web Encryption (JWE) are similar but differ in their use cases and implementations. Swift-JWT supports JWS only. The JWTs created with it cannot be tampered with, because changing the Header or Claims will change the signature of the JWT, invalidating it. However, as the Claims are only Base64 Encoded, they are readable to anyone, but because the Signature can only be validated with public key associated with the private key that signed it, you can trust the token.</p>\n<p>The main benefit of using a JWT is that they are self contained. There is no overhead required, no database lookups, and they can be sent in URLs and HTTP headers. They are also lightweight and human parsable, as they come in JSON format. This means they can be handled easily by applications dealing with JSON. Now we have some priory surrounding JWTs, we can take a look at the API for Swift-JWT.</p>\n<hr>\n<h2 id=\"using-swift-jwt\"><a href=\"#using-swift-jwt\" aria-label=\"using swift jwt permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using Swift-JWT</h2>\n<p>First add the Swift-JWT library to your Package.swift and import it into your project. The library works on Swift 4 and later.</p>\n<p>In my example, I will be using a public/private key pair created on the macOS command line, using OpenSSL and ssh-keygen utilities. The command I used is:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ssh-keygen -t rsa -b 4096 -f jwtRS256.key\n# Don&#39;t add a passphrase\nopenssl rsa -in jwtRS256.key -pubout -outform PEM -out jwtRS256.key.pub</code></pre></div>\n<p>The reason for not adding a passphrase is because this encrypts the key, meaning Swift-JWT can’t read its contents. I then place the files generated into a subdirectory of my Swift project, in the root directory, and call this new directory JWT.</p>\n<p>The data from the file must be parsed into a local variable in Swift so we can use it to instantiate a new JWT object. To do this, we create a URL object pointing to the file and then then create a Data object with the contents of the URL.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> myKeyPath <span class=\"token operator\">=</span> <span class=\"token constant\">URL</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">init</span><span class=\"token punctuation\">(</span>fileURLWithPath<span class=\"token punctuation\">:</span> <span class=\"token function\">getAbsolutePath</span><span class=\"token punctuation\">(</span>relativePath<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/jwt/jwtRS256.key\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> key<span class=\"token punctuation\">:</span> <span class=\"token builtin\">Data</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">Data</span><span class=\"token punctuation\">(</span>contentsOf<span class=\"token punctuation\">:</span> myKeyPath<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span>alwaysMapped<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now the JWT is ready to be created. To do this, you can do the whole thing in one call or create the components separately and then make the JWT at the end. If you are adding a lot of claims to your JWT I would recommend the latter approach for readability.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">var</span> jwt <span class=\"token operator\">=</span> <span class=\"token function\">JWT</span><span class=\"token punctuation\">(</span>header<span class=\"token punctuation\">:</span> <span class=\"token function\">Header</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span>typ<span class=\"token punctuation\">:</span><span class=\"token string\">\"JWT\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span>alg<span class=\"token punctuation\">:</span><span class=\"token string\">\"rsa256\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\nclaims<span class=\"token punctuation\">:</span> <span class=\"token function\">Claims</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">:</span><span class=\"token string\">\"Kitura\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span>jti<span class=\"token punctuation\">:</span>”probableRandomString<span class=\"token string\">\", .iss:”websiteName\"</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">.</span>aud<span class=\"token punctuation\">:</span><span class=\"token string\">\"anyone\"</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span>sub<span class=\"token punctuation\">:</span>”emailOfCLIENT<span class=\"token string\">\", .iat:\"</span><span class=\"token number\">03</span><span class=\"token operator\">/</span><span class=\"token number\">15</span><span class=\"token operator\">/</span><span class=\"token number\">2018</span><span class=\"token string\">\", .exp:\"</span><span class=\"token number\">03</span><span class=\"token operator\">/</span><span class=\"token number\">15</span><span class=\"token operator\">/</span><span class=\"token number\">2019</span>\"<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">.</span>nbf<span class=\"token punctuation\">:</span>”<span class=\"token number\">03</span><span class=\"token operator\">/</span><span class=\"token number\">14</span><span class=\"token operator\">/</span><span class=\"token number\">2018</span>”<span class=\"token punctuation\">,</span> “customClaim”<span class=\"token punctuation\">:</span>”admin<span class=\"token operator\">=</span><span class=\"token constant\">YES</span>”<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>There’s quite a lot going on here so to break it up, we will look at the individual parts of the JWT. First, we create the Header, which takes a .typ parameter of JWT to tell whatever application this is passed into that the contents are a signed JWT (JWS) and not JWE. The .alg field then shows that this is JWS was signed using the RSA256 algorithm.</p>\n<p>The Claims are then created. There are several library provided claims used here, which are defined in the RFC specification, and many are optional. Keep the JWT lightweight and only implement the ones that make sense to your application. In my example, we define a name as “Kitura”, a unique ID for this JWT as “probableRandomString” and so on. For a full list of the available registered claims included, see the file Claims.swift. You can also define your own Claims, known as private claims, which would be application specific using a String as the name of the Claim, as shown above with the customClaim claim.</p>\n<p>We now need to sign the JWT using the private key we made in the terminal. To do this, we run:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token comment\">// Note: You can use a public/private key pair or a certificate to sign a JWT.</span>\n<span class=\"token keyword\">let</span> signedJWT <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> jwt<span class=\"token punctuation\">.</span><span class=\"token function\">sign</span><span class=\"token punctuation\">(</span>using<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span><span class=\"token function\">rs256</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span>privateKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>We create a new JWT that is composed of the three components: a Base64 Encoded Header, Claims object and signature made of the combined two and the key. Someone with access to the public key would then be able to reverse the encoding and verify the signature. The header and claims would be decipherable without the key, as they are only encoded, not encrypted. The signature on the end verifies the validity of the JWT object and allows it to be implicitly trusted.</p>\n<p>A server can send this signed JWT in Kitura with:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\">response<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">[</span><span class=\"token string\">\"Set-Cookie\"</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"jwt=<span class=\"token interpolation\"><span class=\"token delimiter variable\">\\(</span>signedJWT<span class=\"token delimiter variable\">)</span></span>\"</span></code></pre></div>\n<p>A common use case would have a server issuing signed JWTs that a client saves to their local storage. At sometime in the future, the client makes a request and sends the JWT in the Authorisation Header of their HTTP request. The server can use the public key that goes with it’s private key to verify it did make the token using the following syntax:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token comment\">// Inside a route handler for a raw route that requires authentication</span>\n<span class=\"token keyword\">let</span> receivedJWT <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">[</span><span class=\"token string\">\"Cookie\"</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span>separator<span class=\"token punctuation\">:</span> <span class=\"token string\">\";\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> jwt <span class=\"token operator\">=</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">for</span> item <span class=\"token keyword\">in</span> receivedJWT <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> item<span class=\"token punctuation\">.</span><span class=\"token function\">contains</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"jwt\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> separator <span class=\"token operator\">=</span> item<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span>seperator<span class=\"token punctuation\">:</span> <span class=\"token string\">\"=\"</span><span class=\"token punctuation\">)</span>\n        jwt <span class=\"token operator\">=</span> <span class=\"token function\">String</span><span class=\"token punctuation\">(</span>describing<span class=\"token punctuation\">:</span> newArray<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This logic receives a full list of the cookies saved on the client’s system, but we are only interested in the the JWT so we parse it and end with <code class=\"language-text\">cookie</code> storing the value of the received, signed JWT. Now we can verify the JWT was signed by us, and access its Claims. To start, we need to store the public key as a variable we can access in Swift:</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> myPublicKeyPath <span class=\"token operator\">=</span> <span class=\"token constant\">URL</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">init</span><span class=\"token punctuation\">(</span>fileURLWithPath<span class=\"token punctuation\">:</span> <span class=\"token function\">getAbsolutePath</span><span class=\"token punctuation\">(</span>relativePath<span class=\"token punctuation\">:</span> <span class=\"token string\">\"/jwt/jwtRS256.key.public\"</span><span class=\"token punctuation\">)</span><span class=\"token operator\">!</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">var</span> publicKey<span class=\"token punctuation\">:</span> <span class=\"token builtin\">Data</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token function\">Data</span><span class=\"token punctuation\">(</span>contentsOf<span class=\"token punctuation\">:</span> myPublicKeyPath<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span>alwaysMapped<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Now we have it in memory, we can use it to verify the JWT was signed by us, and then use its Claims.</p>\n<div class=\"gatsby-highlight\" data-language=\"swift\"><pre class=\"language-swift\"><code class=\"language-swift\"><span class=\"token keyword\">let</span> verifyJWT <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token constant\">JWT</span><span class=\"token punctuation\">.</span><span class=\"token function\">verify</span><span class=\"token punctuation\">(</span>jwt<span class=\"token punctuation\">,</span> using<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">.</span><span class=\"token function\">rs256</span><span class=\"token punctuation\">(</span>publicKey<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">.</span>publicKey<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">if</span> verifyJWT <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token keyword\">let</span> decodedJWT <span class=\"token operator\">=</span> <span class=\"token keyword\">try</span> <span class=\"token constant\">JWT</span><span class=\"token punctuation\">.</span><span class=\"token function\">decode</span><span class=\"token punctuation\">(</span>jwt<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// Library provided method for checking expiration, audience etc.</span>\n        <span class=\"token keyword\">let</span> claim <span class=\"token operator\">=</span> decodedJWT<span class=\"token punctuation\">.</span><span class=\"token function\">validateClaim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">switch</span> claim <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">case</span> <span class=\"token punctuation\">.</span>success<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\">// Do something if the JWT is valid and trusted.</span>\n        <span class=\"token keyword\">case</span> <span class=\"token punctuation\">.</span>failure<span class=\"token punctuation\">:</span>\n            <span class=\"token comment\">// Do something if the JWT is invalid but trusted (i.e. expired)</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Error decoding JWT\"</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// Do something as JWT was tampered with or not signed by us  </span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>In just a few lines of code, we have received a JWT from the client, checked that we signed it, and checked the validity of the Claims. You can pass an issuer: and audience: parameter into the validateClaims method to check against them. The other claims are only assessed if they are present, if the JWT did not contain them they are skipped.</p>\n<p>Inside the success case is where the logic for your application would go for a successful login. The failure case let’s you deal with cases where the token may be expired or for the wrong audience or issuer and the initial verification lets you be sure you issued the original JWT and it has not been tampered with.</p>\n<hr>\n<h2 id=\"conclusion\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"anchor\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h2>\n<p>The Swift-JWT library will be adding new signing algorithms and use cases as time goes on, and we have added some Claims specific to certain specifications such as MicroProfile. We will also be adding a demo of Swift-JWT to <a href=\"https://github.com/IBM-Swift/Kitura-Sample\">Kitura-Sample</a>, with an example of a simple login and logged-in-user only route and handling on unauthorised access attempts.</p>","frontmatter":{"path":"/blogs/swift-jwt","title":"JSON Web Tokens with Swift-JWT","author":"Kye Maloy","date":"2018-09-02"}}},"pageContext":{"isCreatedByStatefulCreatePages":false}}}