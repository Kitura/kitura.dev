<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-73924704-2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-73924704-2', { 'anonymize_ip': true });
    </script>
    <title>Learn - Getting Started</title>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../../css/reset.css">
    <link rel="stylesheet" href="../../css/docs.css">
    <link href=“https://fonts.googleapis.com/css?family=IBM+Plex+Sans” rel=“stylesheet”>
  </head>
  <body>
    <h1 class="heading-1">Codable Routing</h1>
    <p class="block-text">Codable routing is where the router handlers are just normal functions you might define elsewhere in your code; they take struct or class types as parameters, and respond with struct or class types via a completion handler. The only requirement is that those types conform to the Codable protocol introduced in Swift 4 (hence the name).</p>
    <div class="underline"></div>
    <h2 class="heading-2">Contents:</h2>
    <ol class="plain-list">
      <h3 class="heading-3"><li><a href="#prereq">Prerequisites</a></li></h3>
      <p>This section will inform you of the minimum you need to have setup to follow this guide.</p>
      <h3 class="heading-3"><li><a href="#post">Create a basic POST route</a></li></h3>
      <p>Learn how to send data to a Kitura server using Codable types.</p>
      <h3 class="heading-3"><li><a href="#getall">Create a basic GET ALL route</a></li></h3>
      <p>Learn how to retrieve all data from a Kitura server.</p>
      <h3 class="heading-3"><li><a href="#step3">Create a basic GET SINGLE route</a></li></h3>
      <p>Learn how to get a single value from a Kitura server.</p>
    </ol>
    <div class="underline"></div>
    <h2 class="heading-2" id="prereq">Prerequisites</h2>
    <ul class="plain-list">
      <li><span class="blue-text">Kitura Server:</span> Learn how to create one in our Getting Started guide</li>
      <li><span class="blue-text">Kitura Style Guide:</span> Follow our guide to see how a production ready server should be structed</p>
      <li>You have defined a `Book` struct as described in the Codable routing section of "What is routing?"</li>
    </ul>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 1:</span> Create an in-memory bookstore</h2>
    <p>If you have already completed Raw routing, you can skip this step</p>
    <p class="block-text">Since our route handlers are asynchronous, we will use dispatch to serialize access to our bookstore.
        This will prevent collisions from multiple threads trying to access the same array.
        To be able to use `DispatchQueue` on Linux, add the following statement to the start of the file:</p>
    <pre><code class="language-swift">import Dispatch</code></pre>
    <p> Inside the `App` class, below `let router = Router()` add: </p>
    <pre><code class="language-swift">var bookStore: [Book] = []
let workerQueue = DispatchQueue(label: "worker")</code></pre>
    <p>At the end of the `App` class, add a helper function for atomically executing code:</p>
    <pre><code class="language-swift">func execute(_ block: (() -> Void)) {
   workerQueue.sync {
       block()
   }
}</code></pre>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 2:</span> Create a file to contain the routes</h2>
    <p>Open `Sources` > `Application` > `Application.swift`.</p>
    <p> Inside the `postInit()` function add: </p>
    <pre><code class="language-swift">initializeCodableRoutes(app: self)</code></pre>
    <p>Create a new file called `CodableRoutes.swift` in `Sources` > `Application` > `Routes`.</p>
    <p>Inside this file, add the framework for our routes code: </p>
    <pre><code class="language-swift">import KituraContracts

func initializeCodableRoutes(app: App) {
    // Register routes here
}
extension App {
    // Write bookstore and handlers here
}</code></pre>
    <p>We have imported the KituraContracts library as it contains the shared type definition for `RequestError` which we will use in the next step.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 3:</span> Create a POST Codable Route</h2>
    <p>Inside the `initializeCodableRoutes` function add:</p>
    <pre><code class="language-swift">app.router.post("/codable", handler: app.postHandler)</code></pre>
    <p>What we've done is register a POST on our router that will handle any POST requests made on "/codable".</p>
    <p>This will not compile as we haven't actually implemented the `postHandler` yet, so let's go ahead and do that.</p>
    <p>The `postHandler` is a block of code, called a closure, that is executed when a POST request is made to "/codable".</p>
    <p> Inside the `App` extension add: </p>
    <pre><code class="language-swift">func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
    execute {
         bookStore.append(book)
     }
    completion(book, nil)
}</code></pre>
    <p>We can now successfully compile the project!</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 4:</span> Test the POST route</h2>
    <p>With the project now compiling we can start the server.</p>
    <div class="info">
      <p>Kitura has support for OpenAPI which makes testing Codable routes easy and provides a UI for testing.</p>
      <p>You can add OpenAPI to your server using our OpenAPI guide.</p>
    </div>
    <p>To test the route using curl, open Terminal and enter the following:</p>
    <pre><code>curl -X POST \
  http://localhost:8080/codable \
  -H 'content-type: application/json' \
  -d '{
    "id": 0,
    "title": "A Game of Thrones",
    "price": 14.99,
    "genre": "Fantasy"
}'</code></pre>
    <p>If the Codable route was created correctly we should see the following:</p>
    <pre><code>{"id": 0,"title":"A Game of Thrones","price":14.99,"genre":"Fantasy"}</code></pre>
    <p>We have just successfully posted a book to the server and had it returned.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 5: </span>Create a GET ALL Codable Route</h2>
    <p>We register a GET route in a similar way to the POST route.</p>
    <p>Inside the `initializeCodableRoutes` function add:</p>
    <pre><code class="language-swift">app.router.get("/codable", handler: app.getAllHandler)</code></pre>
    <p>Just like before we now need to define the handler.</p>
    <p> Inside the `App` extension add: </p>
    <pre><code class="language-swift">func getAllHandler(completion: ([Book]?, RequestError?) -> Void) {
    execute {
        completion(bookStore, nil)
    }
}</code></pre>
    <p>You may have noticed that the completion here is expecting an array of books, this is because our route does not provide an identifier, so we retrieve all of the books.</p>
    <p>The result of all the changes should look something like this:</p>
    <p>Now we can restart our server to test our new endpoint.</p>
    <p>Once the server is running, post a book using the curl command in Step 4.</p>
    <p>Open a browser at:</p>
    <p><a href="http://localhost:8080/codable" target="_blank">localhost:8080/codable</a></p>
    <p>This will make a GET request to the server and we should see the book we posted:</p>
    <pre><code>[{
  "id": 0,
  "title": "A Game of Thrones",
  "price": 14.99,
  "genre": "Fantasy"
}]</code></pre>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 6:</span> Create a GET ONE Codable Route</h2>
    <p>Now we will create another GET route. This time we will register a handler for GET requests on "/codable/&lt;id&gt;" which will allow an identifier, &lt;id&gt; to be sent from the client which will identify the book to return information for.</p>
    <p>Inside the `initializeCodableRoutes` function add:</p>
    <pre><code class="language-swift">app.router.get("/codable", handler: app.getOneHandler)</code></pre>
    <p>Just like before we now need to define the handler.</p>
    <p> Inside the `App` extension add: </p>
    <pre><code class="language-swift">func getOneHandler(id: Int, completion: (Book?, RequestError?) -> Void) {
    execute {
        guard id < bookStore.count, id >= 0 else {
            return completion(nil, .notFound)
        }
        completion(bookStore[id], nil)
    }
}</code></pre>
    <p>In the handler, we are provided with an identifier `id`. This is the value following our route and can be either an `Int` or a `String`, in our example we use `Int`, as our model contains an identifier of type `Int`.
    We then use this identifier to return a single `Book.`</p>
    <p>Now we can restart our server to test our new endpoint.</p>
    <p>Once the server is running, open the browser at:</p>
    <p><a href="http://localhost:8080/codable/0" target="_blank">localhost:8080/codable/0</a></p>
    <p>This will make a GET request to the server and we should see the first book in JSON format:</p>
    <pre><code>{
    "id": 0,
    "title": "A Game of Thrones",
    "price": 14.99,
    "genre": "Fantasy"
}</code></pre>
  <p>Now we will POST a second book to the server:</p>
  <pre><code>curl -X POST \
http://localhost:8080/codable \
-H 'content-type: application/json' \
-d '{
  "id": 0,
  "title": "Harry Potter",
  "price": 10.00,
  "genre": "Fantasy"
}'</code></pre>
    <p>Then open the browser at:</p>
    <p><a href="http://localhost:8080/codable/1" target="_blank">localhost:8080/codable/1</a></p>
    <p>This will make a new GET request to the server and we should see the second book in JSON format:</p>
    <pre><code>{"id": 1,"title":"Harry Potter","price":10.00,"genre":"Fantasy"}</code></pre>
    <div class="underline"></div>
    <p>Your completed `CodableRouting.swift` should now look as follows:</p>
<pre><code class="language-swift">import KituraContracts

func initializeCodableRoutes(app: App) {
    // Register routes here
    app.router.post("/codable", handler: app.postHandler)
    app.router.get("/codable", handler: app.getAllHandler)
    app.router.get("/codable", handler: app.getOneHandler)
}
extension App {
    // Write bookstore and handlers here
    func postHandler(book: Book, completion: (Book?, RequestError?) -> Void) {
        execute {
            bookStore.append(book)
        }
        completion(book, nil)
    }

    func getAllHandler(completion: ([Book]?, RequestError?) -> Void) {
        execute {
            completion(bookStore, nil)
        }
    }
    func getOneHandler(id: Int, completion: (Book?, RequestError?) -> Void) {
        execute {
            guard id < bookStore.count, id >= 0 else {
                return completion(nil, .notFound)
            }
            completion(bookStore[id], nil)
        }
    }
}
</code></pre>
    <h2 class="heading-2">Next steps</h2>
    <p><span class="blue-text bold"><a onclick="setActiveSidebarElementForParent('open-api')" href="open-api.html#">Add Kitura OpenAPI:</a></span> Provides a UI for viewing information about Codable routes.</p>
    <!-- <p><span class="blue-text bold">Add Sessions:</span> Some blurb about Sessions</p>
    <p><span class="blue-text bold">Add Authentication:</span> Some blurb about Authentication</p> -->
    <script type="text/javascript" src="../../scripts/docs.js"></script>
    <script type="text/javascript" src="../../scripts/prism.js"></script>
  </body>
</html>
