<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
			<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-73924704-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

		gtag('config', 'UA-73924704-2', { 'anonymize_ip': true });
</script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=0">
    <title>Authentication with JWT</title>
    <link rel="icon" type="image/png" href="../../assets/favicon-32x32.png" sizes="32x32" />
    <link rel="icon" type="image/png" href="../../assets/favicon-16x16.png" sizes="16x16" />
    <link href=“https://fonts.googleapis.com/css?family=IBM+Plex+Sans” rel=“stylesheet”>
    <link rel="stylesheet" href="../../css/reset.css">
    <link rel="stylesheet" href="../../css/dist/docs.css">
  </head>
<body>
  <section class="docs-grid-container">
    <aside id="sidebar" class="docs-item-1 docs-sidebar">
      <h1 class="docs-title"><a href="/index.html">KITURA <span class="blue-text">DOCS</span></a></h1>
      <div class="underline-title"></div>
      <ul class="sidebar-list">
        <li class="sidebar-item collapsible">Getting Started</li>
        <ul class="nested-sidebar-list content">
          <li class="nested-sidebar-item"><a href="../getting-started/installation-mac.html">Installation for macOS</a></li>
          <li class="nested-sidebar-item"><a href="../getting-started/installation-linux.html">Installation for Linux</a></li>
          <li class="nested-sidebar-item"><a href="../getting-started/create-server.html">Create a server</a></li>
          <li class="nested-sidebar-item"><a href="../getting-started/style-guide.html">Style Guide</a></li>
          <li class="nested-sidebar-item"><a href="../getting-started/update-package.html">Adding Packages</a></li>
        </ul>
        <li class="sidebar-item collapsible">Logging</li>
        <ul class="nested-sidebar-list content">
          <li class="nested-sidebar-item"><a href="../logging/logging.html">What is Logging?</a></li>
          <li class="nested-sidebar-item"><a href="../logging/helium-logger.html">Helium Logger</a></li>
        </ul>
        <li class="sidebar-item collapsible">Routing</li>
        <ul class="nested-sidebar-list content">
          <li class="nested-sidebar-item"><a href="../routing/routing.html">What is routing?</a></li>
          <li class="nested-sidebar-item"><a href="../routing/codable-routing.html">Codable routing</a></li>
          <li class="nested-sidebar-item"><a href="../routing/raw-routing.html">Raw routing</a></li>
          <li class="nested-sidebar-item"><a href="../routing/open-api.html">OpenAPI</a></li>
        </ul>
        <li class="sidebar-item collapsible">Databases</li>
        <ul class="nested-sidebar-list content">
          <li class="nested-sidebar-item"><a href="../databases/databases.html">What are Databases?</a></li>
          <li class="nested-sidebar-item"><a href="../databases/swift-kuery-orm.html">SQL: ORM</a></li>
          <li class="nested-sidebar-item"><a href="../databases/swift-kuery.html">SQL: Kuery</a></li>
          <li class="nested-sidebar-item"><a href="../databases/couchdb.html">NoSQL: CouchDB</a></li>
        </ul>
        <li class="sidebar-item collapsible">Sessions</li>
        <ul class="nested-sidebar-list content">
          <li class="nested-sidebar-item"><a href="../sessions/sessions.html">What are Sessions?</a></li>
          <li class="nested-sidebar-item"><a href="../sessions/kitura-session.html">Raw Routing Session</a></li>
          <li class="nested-sidebar-item"><a href="../sessions/type-safe-session.html">Codable Routing Session</a></li>
        </ul>
        <li class="sidebar-item collapsible">Authentication</li>
        <ul class="nested-sidebar-list content" style="max-height: 100%">
          <li class="nested-sidebar-item"><a href="../authentication/authentication.html">What is Authentication?</a></li>
          <li class="nested-sidebar-item"><a href="../authentication/typesafe-auth.html">Type-Safe Credentials</a></li>
          <li class="nested-sidebar-item active"><a href="../authentication/jwt-auth.html">JSON Web Tokens</a></li>
          <li class="nested-sidebar-item"><a href="../authentication/fb-google-oauth2.html">OAuth 2.0 with Facebook/Google</a></li>
        </ul>
        <li class="sidebar-item collapsible">Web Application</li>
        <ul class="nested-sidebar-list content">
          <li class="nested-sidebar-item"><a href="../templating/templating.html">What is templating?</a></li>
          <li class="nested-sidebar-item"><a href="../templating/static-file-server.html">Static File Server</a></li>
          <li class="nested-sidebar-item"><a href="../templating/stencil.html">Stencil</a></li>
          <li class="nested-sidebar-item"><a href="../templating/markdown.html">Markdown</a></li>
        </ul>
        <li class="sidebar-item collapsible">Deploying</li>
        <ul class="nested-sidebar-list content">
          <li class="nested-sidebar-item"><a href="../deploying/monitoring.html">Monitoring</a></li>
          <li class="nested-sidebar-item"><a href="../deploying/ssl.html">Enabling SSL/TLS</a></li>
          <li class="nested-sidebar-item"><a href="../deploying/docker.html">Docker</a></li>
          <li class="nested-sidebar-item"><a href="../deploying/kubernetes.html">Kubernetes</a></li>
          <li class="nested-sidebar-item"><a href="../deploying/cloud-foundry.html">Cloud Foundry</a></li>
        </ul>
      </ul>
    </aside>
    <div id="burgerIcon" class="burger-icon" onclick="showSidebar()">
      <div class="burger-line"></div>
      <div class="burger-line"></div>
      <div class="burger-line"></div>
    </div>
    <div class="docs-item-2 search-container">
      <!-- <input class="docs-search" type="text" name="searchInput" placeholder="Search documentation..."> -->
      <div id="beta" class="temp-beta">
        <h4>Currently in Beta - <a href="../../old-learn.html">View old docs</a></h4>
      </div>
    </div>
    <nav class="docs-item-3 docs-nav">
      <button id="api-button" class="apiref-button" type="button" name="button" onclick="window.open('https://ibm-swift.github.io/Kitura/')">API Reference</button>
      <a class="nav-item" target="_blank" href="http://slack.kitura.io/">Need help?</a>
      <a class="nav-item" target="_blank" href="https://github.com/IBM-Swift/kitura.io/issues">Found an issue?</a>
    </nav>
    <div id="doc-container" class="docs-item-4 docs-window">
      <main>
      <h1 class="heading-1">JSON Web Token Authentication</h1>
      <p class="block-text">A JSON Web Token (JWT) defines a compact and self-contained way for securely transmitting information between parties as a JSON object. You can find out more about JWTs at `JWT.IO`.</p>
      <p class="block-text"> <a href="https://github.com/IBM-Swift/Swift-JWT" target="_blank">Swift-JWT</a> is our implementation of JSON Web Token using Swift.
           It allows you to create sign and verify JWTs on iOS, macOS and Linux using a range of algorithms.
           This guide will demonstrate how to use Swift-JWT to implement Single Sign On (SSO) authentication for your Kitura routes.
           This will allow a user to sign in once and then to access resources from other routes without having to repeat the authentication process.</p>
      <h2 class="heading-2">Prerequisites</h2>
      <ul class="plain-list">
        <li><a onclick="setActiveSidebarElementForParent('create-server')" href="../getting-started/create-server.html#">Kitura Server:</a> Learn how to create one in our Getting Started guide.</li>
        <li><a onclick="setActiveSidebarElementForParent('style-guide')" href="../getting-started/style-guide.html#">Kitura Style Guide:</a> Follow our guide to see how a production ready server should be structured.</li>
        <li><a onclick="setActiveSidebarElementForParent('style-guide')" href="../getting-started/style-guide.html#">Book Model:</a> Define a Book model, as described in Step 5 of the Style Guide.</li>
        <li><a onclick="localStorage.setItem('package', 'Swift-JWT'); setActiveSidebarElementForParent('swift-jwt')" href="../getting-started/update-package.html#">Update Dependencies:</a> Swift-JWT needs adding to the `Package.swift` file.</li>
      </ul>
      <div class="underline"></div>
      <h2 class="heading-2">JWT Authentication</h2>
      <h2 class="heading-2"><span class="blue-text">Step 1:</span> Create the JWT routes</h2>

      <p>Firstly, open your `Application.swift` file in your default text editor:</p>
      <pre><code>open Sources/Application/Application.swift</code></pre>
      <p> Inside the `postInit()` function add: </p>
      <pre><code class="language-swift">initializeJWTRoutes(app: self)</code></pre>
      <p>Create a new file, called `JWTRoutes.swift`:</p>
      <pre><code>touch Sources/Application/Routes/JWTRoutes.swift</code></pre>
      <p>Open your `JWTRoutes.swift` file:</p>
      <pre><code>open Sources/Application/Routes/JWTRoutes.swift</code></pre>
      <p>Inside this file, add the following code:</p>
      <pre><code class="language-swift">import Foundation
import KituraContracts
import SwiftJWT

func initializeJWTRoutes(app: App) {
    app.router.post("/jwtlogin") { request, response, next in
        // Read credentials and generate JWT here
        next()
    }

    app.router.get("/jwtprotected") { request, response, next in
        // Verify JWT here
        next()
    }
}
extension App {
  // Define JWT signer and verifier here
}</code></pre>
<p class="block-text">This code imports our requires modules,
     sets up the framework for a routes page
      and defines the two raw routes that we will use in our guide.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 2:</span> Set up your signing and verifying algorithm</h2>
<p class="block-text">Swift-JWT supports multiple algorithms for signing and verifying JWTs as defined by <a href="https://tools.ietf.org/html/rfc7518#section-3.1" target="_blank">RFC7518</a>.
    This is implemented by creating a `JWTSigner` and `JWTVerifier` struct with a required credentials.
</p>
<p>Click on one of the tabs below to see how and why you would use each algorithm.</p>
    <section class="tab">
      <div class="tab-buttons">
        <button id="jwt-button" type="button" name="button" class="tablinks hmac" onclick="openPlugin('hmac', '')">HMAC</button>
        <button type="button" name="button" class="tablinks ecdsa" onclick="openPlugin('ecdsa', '')">ECDSA</button>
        <button type="button" name="button" class="tablinks rsa" onclick="openPlugin('rsa', '')">RSA</button>
      </div>
      <div class="tabcontent hmac">
          <p class="block-text">You can process JWTs using a Hashed Message Authentication Code (HMAC).
               This uses a shared symmetric key as a password for both signing and verifying.
                This is simple and fast but requires a secure method of sending the password to the verifier.</p>
        <h2 class="heading-2"><span class="blue-text">Step 2a:</span> Create your JWTSigner</h2>
        <p>The `JWTSigner` is used to sign a `JWT` instance and produce a signed JWT string.</p>
        <p>Inside the `App` extension, create an HMAC `JWTSigner` by providing a password:</p>
        <pre><code class="language-swift">static let jwtSigner = JWTSigner.hs256(key: Data("kitura".utf8))</code></pre>
        <h2 class="heading-2"><span class="blue-text">Step 2b:</span> Create your JWTVerifier</h2>
        <p>The `JWTVerifier` is used to verify a signed JWT string.
             This ensures the signature was generated using the same password and the JWT has not been changed.</p>
        <p>Inside the `App` extension, we create an HMAC `JWTVerifier` by providing the same password as before:</p>
        <pre><code class="language-swift">static let jwtVerifier = JWTVerifier.hs256(key: Data("kitura".utf8))</code></pre>
      </div>
      <div class="tabcontent ecdsa">
      <p class="block-text">You can process JWTs using Elliptic Curve Digital Signature Algorithm (ECDSA).
            This uses asymmetric keys with a private key for signing and a public key for verifying.
            The public key allows anyone to verify a JWT but only the provider can create them.
            ECDSA is recommended over RSA since it uses smaller keys, requires less processing power and produces smaller signatures.</p>
        <h2 class="heading-2"><span class="blue-text">Step 2a:</span> Create your elliptic curve keys</h2>
        <p>Elliptic curve keys can be generated through
             <a href="https://developer.apple.com/account/ios/authkey" rel="noopener" target="_blank">Apple</a>,
             <a href="https://wiki.openssl.org/index.php/Command_Line_Elliptic_Curve_Operations#Generating_EC_Keys_and_Parameters" rel="noopener" target="_blank">OpenSSL</a>
              or using <a href="https://github.com/IBM-Swift/BlueECC#elliptic-curve-private-key" rel="noopener" target="_blank">BlueECC</a>.</p>
              <p>For simplicity you can use the following pre-generated keys.</p>
        <p>Add the following EC PEM strings (Or strings you have generated) to your `App` extension:<p>
    <pre><code class="language-swift">static let privateKey = """
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIJX+87WJ7Gh19sohyZnhxZeXYNOcuGv4Q+8MLge4UkaZoAoGCCqGSM49
AwEHoUQDQgAEikc5m6C2xtDWeeAeT18WElO37zvFOz8p4kAlhvgIHN23XIClNESg
KVmLgSSq2asqiwdrU5YHbcHFkgdABM1SPA==
-----END EC PRIVATE KEY-----
"""
static let publicKey = """
-----BEGIN PUBLIC KEY-----
MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEikc5m6C2xtDWeeAeT18WElO37zvF
Oz8p4kAlhvgIHN23XIClNESgKVmLgSSq2asqiwdrU5YHbcHFkgdABM1SPA==
-----END PUBLIC KEY-----
"""</code></pre>
    <h2 class="heading-2"><span class="blue-text">Step 2b:</span> Create your JWTSigner</h2>
    <p>The `JWTSigner` is used to sign a `JWT` instance and produce a signed JWT string.</p>
    <p>Inside the `App` extension, create an ECDSA `JWTSigner` by providing the private key:</p>
    <pre><code class="language-swift">@available(OSX 10.13, *)
        static let jwtSigner = JWTSigner.es256(privateKey: Data(privateKey.utf8))</code></pre>
    <div class="info">
        <p>ECDSA algorithms such as `es256` use <a href="https://github.com/IBM-Swift/BlueECC" target="_blank">BlueECC</a>, which is only available on macOS 10.13 or newer.
            When using them you will need to us `@available` to handle cases where the operating system version is not high enough.</p>
    </div>
    <h2 class="heading-2"><span class="blue-text">Step 2c:</span> Create your JWTVerifier</h2>
    <p>The `JWTVerifier` is used to verify a signed JWT string.
         This ensures the signature was generated using the corresponding private key and the JWT has not been changed.</p>
    <p>Inside the `App` extension, we create an ECDSA `JWTVerifier` by providing the public key:</p>
    <pre><code class="language-swift">@available(OSX 10.13, *)
        static let jwtVerifier = JWTVerifier.es256(publicKey: Data(publicKey.utf8))</code></pre>
      </div>
      <div class="tabcontent rsa">
          <p class="block-text">You can process JWTs using RSA cryptography.
                This uses asymmetric keys with a private key for signing and a public key for verifying.
                The public key allows anyone to verify a JWT but only the provider can create them.
                ECDSA is recommended over RSA since it uses smaller keys, requires less processing power and produces smaller signatures.</p>
            <h2 class="heading-2"><span class="blue-text">Step 2a:</span> Create your RSA keys</h2>
            <p>You can generate RSA keys in terminal using the following OpenSSL commands:</p>
            <pre><code>openssl genrsa -out privateKey.pem 2048</code></pre>
            <pre><code>openssl rsa -in privateKey.pem -pubout -outform PEM -out publicKey.pem</code></pre>
            <p>For simplicity you can use the following pre-generated keys.</p>
            <p>Add the following RSA PEM strings (Or the ones you generated) to your `App` extension:<p>
        <pre><code class="language-swift">static let privateKey = """
-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEAxyebvXKgG7VHTUArwIPLL6uruJuaYTuspaI793JQK/3XIJ1O
8KRXqWvy2Awo+po1IeKIGioCwD7mVbN2oX9yC8K+VDUJrpxz1Bve+zLZ59x81TO0
IlgbugjduGBmnKTElL/Y7MbI2SIJheBfxqcvopc5U+j3eVLvl3mTPx5T9i/qutmw
L7qfk/bOOgV3sMVa/Q9SXE4ZE1737UHUgcBJFp5okqSKBQw6kxZ7HsDSLDIZJRKH
vW3NiCIrK83JvQp4tYWi4Sb3rDl3TyRlqDM4Ly0YQ6be5IsPfmut8NENDoviyZRd
ihnN6TuBk3zUfb4MkcO/KUGub37zRQbgB5KQmwIDAQABAoIBAQCal/N8HxOMDq8X
l12fJm8+RPua5Sb0nXcKaCI2lgUH8RbimVoi0N+/gy1SajYROk1OTWOrM7tI8kqo
chP/j0e/O1+1TCqE4avEFhKEWlfudSht86G8GzsCsUkzi5l7tSdn9Hh2bGSSsKpF
wwN12GfQxaTZrvkTs76KjfQwReGVMwPf5D67968Eani+sj02ODYT99sQd0Zs9Jkd
nqjIkDCeAQYgUUpsut/0mtodwrJlQXGS1DjOSfbUbdXTzQOR6a5uHMCdqNG2Dqrv
GkzdViwzAfwNz3ntdqn2YVnCPQwdOArrP6iKIPukMC5zckMCdcvoeEOLY+7SwGvB
srWM7Xj5AoGBAO7OhOOAWoI9RJ2onfrB4xi84cdcnAq+lQij//yC+rTNC4fu7eJp
MbF9C7P7XicD2xTJgfjddYW7H6yc5t2BChmICXbEv0K0/kebc5MzaZK264u9fxk6
MToLWReCFYQ5pmqgqeKJ2CV86byDFYVf0cSt4PcpOXfdHQzjA/S5qMslAoGBANV+
QfTBQe/bkTVRRlY1YcghPZr6sR7cUbyXX0ou8dDdAdSZ1VOwDmIZhnq0/w/HzJQm
UMw2zjs37y9Mf60xLlvY8bbhU1rlZ8vZr+0xm8K4fYlnt+ONNjv6puYvF5IPKad3
KvafIOelY8liLqo9gXJYUZGZcxRikiKtZotQJwC/AoGBAN3rz3S3p+SWWTiGJOGN
4qPvi4XAG0ak20yfU1luwtrYHdoiALFB/qspQIHunA13uNU1efIyo282ePXpDWZU
73TQhbL4naC5IACdhqcJxRdRo81FuWJRQMPnHdEJ00MAbBV03ssmPFaCIZhM3OgI
JqE20PP/PGeWdNOv99Ip4qF9AoGAGeGxi0N2g+aBZw5QUZktHn7xIf2sRUp+Wjeb
pLmmNSTl2OlBVGDujXP8upmApmAZbAhtGSS3wbQZOgmzHMLulNHrE7mjSkyvVaYx
TrcJ5ARLq8G4KEzxOzo6y4L//4P5D8VBnx5RdeO2Ai7160uDiuIsGVOaAOmmP6/3
04HHCK8CgYEAuS4wfgKWL9nRInjOjrKd9SSnHFWbmD4PfrbjtNY69R3FqryTmT1e
9GUyAQTpdIn46LYDczkQJpg8TIN/3yDHb9TErmspsAEDnFHD7Dsxi0LlbPkSdhls
cQGNrHxp2xvM+LKFW1y3K6XUJhZZSKEVQvR3v4QVxCUxglbGJ5BTNXY=
-----END RSA PRIVATE KEY-----
"""
static let publicKey = """
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxyebvXKgG7VHTUArwIPL
L6uruJuaYTuspaI793JQK/3XIJ1O8KRXqWvy2Awo+po1IeKIGioCwD7mVbN2oX9y
C8K+VDUJrpxz1Bve+zLZ59x81TO0IlgbugjduGBmnKTElL/Y7MbI2SIJheBfxqcv
opc5U+j3eVLvl3mTPx5T9i/qutmwL7qfk/bOOgV3sMVa/Q9SXE4ZE1737UHUgcBJ
Fp5okqSKBQw6kxZ7HsDSLDIZJRKHvW3NiCIrK83JvQp4tYWi4Sb3rDl3TyRlqDM4
Ly0YQ6be5IsPfmut8NENDoviyZRdihnN6TuBk3zUfb4MkcO/KUGub37zRQbgB5KQ
mwIDAQAB
-----END PUBLIC KEY-----
"""</code></pre>
        <h2 class="heading-2"><span class="blue-text">Step 2b:</span> Create your JWTSigner</h2>
        <p>The `JWTSigner` is used to sign a `JWT` instance and produce a signed JWT string.</p>
        <p>Inside the `App` extension, create an RSA `JWTSigner` by providing the private key:</p>
        <pre><code class="language-swift">static let jwtSigner = JWTSigner.rs256(privateKey: Data(privateKey.utf8))</code></pre>
        <h2 class="heading-2"><span class="blue-text">Step 2c:</span> Create your JWTVerifier</h2>
        <p>The `JWTVerifier` is used to verify a signed JWT string.
             This ensures the signature was generated using the corresponding private key and the JWT has not been changed.</p>
        <p>Inside the `App` extension, we create an RSA `JWTVerifier` by providing the public key:</p>
        <pre><code class="language-swift">static let jwtVerifier = JWTVerifier.rs256(publicKey: Data(publicKey.utf8))</code></pre>
      </div>
    </section>
    <div class="underline"></div>

    <h2 class="heading-2"><span class="blue-text">Step 3:</span> Define a model to represent the user's credentials</h2>
    <p class="block-text">For the initial authentication, the user will have to provide their username and password.
         This could be achieved with basic authentication, the Authorization header or in the body of a POST request.
         In this guide we will pass the username and password in the body of a POST request and use a model to represent this.</p>
         <div class="info">
           <p>Passwords and signed JWTs must be kept private and should always be exchanged over a secure layer like HTTPS.</p>
         </div>
        <p>Create a new file, called `UserCredentials.swift`:</p>
        <pre><code>touch Sources/Application/Models/UserCredentials.swift</code></pre>
        <p>Open your `UserCredentials.swift` file:</p>
        <pre><code>open Sources/Application/Models/UserCredentials.swift</code></pre>
        <p>Inside this file we define our UserCredentials model:</p>
        <pre><code class="language-swift">struct UserCredentials: Codable {
    let username: String
    let password: String
}</code></pre>
    <div class="underline"></div>

    <h2 class="heading-2"><span class="blue-text">Step 4:</span> Authenticate the User</h2>
    <p class="block-text">We need to read the user's credentials in our POST route so they can be authenticated.</p>
    <p>Inside the POST route add:</p>
    <pre><code class="language-swift">let credentials = try request.read(as: UserCredentials.self)
// Users credentials are authenticated</code></pre>
    <p>At this stage, you would normally hash the password and verify it against a database.
        However, for simplicity, we are going to assume the user successfully logged in.</p>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 5:</span> Create the signed JWT</h2>
    <p class="block-text">A JWT contains claims about the user that we want include in subsequent requests.
         You can specify any information as a claim, however there are "Registered Claims" which have a pre-defined meaning:</p>
         <ul>
           <li>iss: The issuer of the token. </li>
           <li>sub: The subject of the token.</li>
           <li>aud: The audience of the token.</li>
           <li>exp: The expiration time which MUST be after the current date/time.</li>
           <li>nbf: Defines the time before which the JWT MUST NOT be accepted for processing.</li>
           <li>iat: The time the JWT was issued. Can be used to determine the age of the JWT.</li>
           <li>jti: Unique identifier for the JWT. Can be used to prevent the JWT from being replayed.</li>
         </ul>
    <p>Swift-JWT comes with a struct representing these Registered Claims which we will use for our example.</p>
    <p>Inside the POST route, beneath the code where we authenticated the user, initialize the user's claims:</p>
    <pre><code class="language-swift">let myClaims = ClaimsStandardJWT(iss: "Kitura", sub: credentials.username, exp: Date(timeIntervalSinceNow: 3600))</code></pre>
    <p>The claims information tells us the username which is the subject of the token, that they were authenticated by Kitura and that the token will expire in one hour.</p>
    <p>Next, we will initialize our JWT:</p>
    <pre><code class="language-swift">var myJWT = JWT(claims: myClaims)</code></pre>
    <p>We can sign this JWT using the `JWTSigner` we created in step 2:</p>
    <pre><code class="language-swift">let signedJWT = try myJWT.sign(using: App.jwtSigner)</code></pre>
    <p>Finally we return the signed JWT string to the user:</p>
    <pre><code class="language-swift">response.send(signedJWT)</code></pre>
    <p>Our completed login route should look as follows:</p>
    <pre><code class="language-swift">app.router.post("/jwtlogin") { request, response, next in
    let credentials = try request.read(as: UserCredentials.self)
    // Users credentials are authenticated
    let myClaims = ClaimsStandardJWT(iss: "Kitura", sub: credentials.username, exp: Date(timeIntervalSinceNow: 3600))
    var myJWT = JWT(claims: myClaims)
    let signedJWT = try myJWT.sign(using: App.signer)
    response.send(signedJWT)
    next()
}</code></pre>
<div class="underline"></div>

<h2 class="heading-2"><span class="blue-text">Step 6:</span> Test the JWT creation</h2>
<p>Compile your project and start the server.</p>
<p>To test the route using curl, open Terminal and enter the following:</p>
<pre><code>curl -X POST \
    http://localhost:8080/jwtlogin \
    -H 'content-type: application/json' \
    -d '{
    "username": "Joe Bloggs",
    "password": "password"
}'</code></pre>
<p>You should be returned a JWT string that is structured `xxxx.yyyy.zzzz`
     where xxxx is the base64 encoded header, yyyy is the base 64 encoded claims and zzzz is the signature.</p>
<p>Below is an example JWT, generated using `HS256` and the password "kitura":<p>
<pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJLaXR1cmEiLCJzdWIiOiJKb2UgQmxvZ2dzIiwiZXhwIjoxNTUzMDE4Mjg0LjMyOTcwMTl9.t55WealACtYGCQGS3EQgRQuurmNSBO5fWZqzqJjEIi</code></pre>
<p>We can decode the JWT string using the debugger at <a href="https://jwt.io/#debugger" rel="noopener" target="_blank">JWT.IO</a> which allows us view the headers and claims.</p>
    <div class="underline"></div>

    <h2 class="heading-2"><span class="blue-text">Step 7:</span> Verify a JWT</h2>
    <p class="block-text">So far, we have created a signed JWT, which allows a user to authenticate themselves.
         At this stage, the user would attach the JWT string to future requests either using cookies or the Authorization header.
     When we receive this JWT string on other routes, we need to verify that we signed it and it hasn't been altered.</p>
     <p>Let's start by reading the JWT string from the Authorization header of the request.
        The JWT string will be contained within the second component of the header,
         so we validate that there are only two components within the header
          and that the first contains the string "Bearer".</p>
     <p>Inside the GET route, add the following code:</p>
     <pre><code class="language-swift">let authHeader = request.headers["Authorization"]
guard let authComponents = authHeader?.components(separatedBy: " "),
    authComponents.count == 2,
    authComponents[0] == "Bearer"
else {
    let _ = response.send(status: .unauthorized)
    return try response.end()
}</code></pre>
    <p>The JWT string will be `authComponents[1]`, so we will verify this string and use it to initialize a JWT.</p>
    <p>Add the following code to your guard statement, below `authComponents[0] == "Bearer"`:</p>
    <pre><code class="language-swift">let jwt = try? JWT&lt;ClaimsStandardJWT&gt;(jwtString: authComponents[1], verifier: App.jwtVerifier)</code></pre>
    <p class="block-text">There we have it, the user's JWT is now available for us to use within our route.
         If we successfully initialized the JWT using the jwtVerifier,
          we know that we signed it in the first place and the contents haven't been changed.
          If the signature isn't verified, we reject the request and return the 401 unauthorized status code.</p>
    <p>To finish, let's send the decoded JWT back to the user.</p>
    <p>After the else closure, add the following code:</p>
    <pre><code class="language-swift">response.send(jwt)</code></pre>
    <p>Your completed GET route should now look as follows:</p>
    <pre><code class="language-swift">app.router.get("/jwtprotected") { request, response, next in
    let authHeader = request.headers["Authorization"]
    guard let authComponents = authHeader?.components(separatedBy: " "),
        authComponents.count == 2,
        authComponents[0] == "Bearer",
        let jwt = try? JWT&lt;ClaimsStandardJWT&gt;(jwtString: authComponents[1], verifier: App.jwtVerifier)
    else {
        let _ = response.send(status: .unauthorized)
        return try response.end()
    }
    response.send(jwt)
    next()
}</code></pre>
    <div class="underline"></div>

    <h2 class="heading-2"><span class="blue-text">Step 8:</span> Test the protected Route</h2>
    <p>To test this, restart your server and send the POST request from Step 6.</p>
    <p>Copy the returned JWT string and paste it into the following curl request:<p>
<pre><code>curl -X GET \
http://localhost:8080/jwtprotected \
-H 'content-type: application/json' \
-H 'Authorization: Bearer &lt;Your JWT string here&gt;'</code></pre>
<p>You should see your JWT with your username returned to you. This should look something like:</p>
<pre><code>{"claims":{"iss":"Kitura","sub":"Joe Bloggs","exp":574703307.61258602},"header":{"typ":"JWT","alg":"ES256"}}</code></pre>
<p>Congratulations! We have just created a JWT single sign on system using a Kitura Server.
     Your completed `JWTRoutes.swift` file for `HS256` should look as follows:</p>
<pre><code class="language-swift">import KituraContracts
import SwiftJWT
import Foundation


func initializeJWTRoutes(app: App) {

    app.router.post("/jwtlogin") { request, response, next in
        let credentials = try request.read(as: UserCredentials.self)
        let myClaims = ClaimsStandardJWT(iss: "Kitura", sub: credentials.username, exp: Date(timeIntervalSinceNow: 3600))
        var myJWT = JWT(claims: myClaims)
        let signedJWT = try myJWT.sign(using: App.jwtSigner)
        response.send(signedJWT)
        next()
    }

    app.router.get("/jwtprotected") { request, response, next in
        let authHeader = request.headers["Authorization"]
            guard let authComponents = authHeader?.components(separatedBy: " "),
                authComponents.count == 2,
                authComponents[0] == "Bearer",
                let jwt = try? JWT&lt;ClaimsStandardJWT&gt;(jwtString: authComponents[1], verifier: App.jwtVerifier)
                else {
                    let _ = response.send(status: .unauthorized)
                    return try response.end()
            }
        response.send(jwt)
        next()
    }
}

extension App {
    // Example for HMAC signer and verifier
    static let jwtSigner = JWTSigner.hs256(key: Data("kitura".utf8))
    static let jwtVerifier = JWTVerifier.hs256(key: Data("kitura".utf8))
}</code></pre>
    <div class="underline"></div>
    <h2 class="heading-2"><span class="blue-text">Step 9:</span> JWTs on Codable Routes (Optional)</h2>
    <p class="block-text">In our example we used raw routing since we chose to pass the user credentials via the request headers.
         If we want to use JWTs on our codable routes, we need to encapulate the verification and creation of the users JWT in a `TypeSafeMiddleware`.
     We can then register our `TypeSafeMiddleware` on a Codable route to authenticate the user and access their claims.</p>
    <h2 class="heading-2"><span class="blue-text">Step 9a:</span> Define our type safe middleware.</h2>
    <p>Create a new file called `TypeSafeJWT.swift` in `Sources` > `Application` > `Middlewares`</p>
    <p>Inside this file, define `TypeSafeJWT` with the following code:</p>
<pre><code class="language-swift">import SwiftJWT
import Kitura

struct TypeSafeJWT&lt;C: Claims&gt;: TypeSafeMiddleware {
    static func handle(request: RouterRequest, response: RouterResponse, completion: @escaping (TypeSafeJWT<C>?, RequestError?) -> Void) {

    }
}</code></pre>
    <p class="block-text">The `TypeSafeMiddleware` protocol requires us to implement the `handle` function.
         This function is where we will interact with the request headers;
          we then return an instance of `TypeSafeJWT` on success, or a `RequestError` on failure.
          The `TypeSafeJWT` struct is generic so it can be used on any JWT.</p>
    <p>Within the handler we are interested in the decoded JWT so we add that as a field:</p>
    <pre><code class="language-swift">let jwt: JWT&lt;C&gt;</code></pre>
    <p>Finally, we initialize our JWT using the same functions as Step 7 for our protected GET route.</p>
    <p>Inside our handle function, add the following:</p>
    <pre><code class="language-swift">let authHeader = request.headers["Authorization"]
guard let authComponents = authHeader?.components(separatedBy: " "),
    authComponents.count == 2,
    authComponents[0] == "Bearer",
    let jwt = try? JWT&lt;C&gt;(jwtString: authComponents[1], verifier: App.jwtVerifier)
else {
    return completion(nil, .unauthorized)
}
completion(TypeSafeJWT(jwt: jwt), nil)</code></pre>
<p>Your completed `TypeSafeJWT.swift` file should look as follows:</p>
<pre><code class="language-swift">import SwiftJWT
import Kitura

struct TypeSafeJWT&lt;C: Claims&gt;: TypeSafeMiddleware {
    let jwt: JWT&lt;C&gt;
    static func handle(request: RouterRequest, response: RouterResponse, completion: @escaping (TypeSafeJWT<C>?, RequestError?) -> Void) {
        let authHeader = request.headers["Authorization"]
        guard let authComponents = authHeader?.components(separatedBy: " "),
            authComponents.count == 2,
            authComponents[0] == "Bearer",
            let jwt = try? JWT&lt;C&gt;(jwtString: authComponents[1], verifier: App.jwtVerifier)
        else {
            return completion(nil, .unauthorized)
        }
        completion(TypeSafeJWT(jwt: jwt), nil)
    }
}</code></pre>
<div class="underline"></div>

<h2 class="heading-2"><span class="blue-text">Step 9b:</span> Register TypeSafeJWT on a route.</h2>
    <p>Back in our routes file, `JWTRoutes.swift`, we are going to register a new route using our `TypeSafeMiddleware`.</p>
    <p>In the function `initializeJWTRoutes`, add a new route called "/jwtCodable"</p>
    <pre><code class="language-swift">app.router.get("/jwtCodable", handler: app.typeSafeHandler)</code></pre>
    <p>In your `App` extension, define the typeSafeHandler:</p>
<pre><code class="language-swift">func typeSafeHandler(typeSafeJWT: TypeSafeJWT&lt;ClaimsStandardJWT&gt;, completion: (JWT&lt;ClaimsStandardJWT>?, RequestError?) -> Void) {
    completion(typeSafeJWT.jwt, nil)
}</code></pre>
    <p>This function will run the middleware, `TypeSafeJWT`, and if it succeeds it will return the JWT instance, just as we did in our raw routing example above.</p>
    <div class="underline"></div>

    <h2 class="heading-2"><span class="blue-text">Step 9c:</span> Test the new Codable route</h2>
    <p>To test this route, restart your server and send the POST request from Step 6.</p>
    <p>Copy the returned JWT string and paste it into the following curl request:<p>
<pre><code>curl -X GET \
http://localhost:8080/jwtCodable \
-H 'content-type: application/json' \
-H 'Authorization: Bearer &lt;Your JWT string here&gt;'</code></pre>
<p>We should see your JWT with your username returned to you. This should look something like:</p>
<pre><code>{"claims":{"iss":"Kitura","sub":"Joe Bloggs","exp":574703307.61258602},"header":{"typ":"JWT","alg":"ES256"}}</code></pre>
    <div class="underline"></div>
    <h3 class="heading-3">Next steps</h3>
            <p><span class="blue-text bold"><a onclick="setActiveSidebarElementForParent(`templating`)" href="../templating/templating.html#">Web Application:</a></span> Learn about web applications and what Kitura provides.</p>
</main>
    </div>
    <div id="top-page" class="top-page">
      <a href="#">Back to top</a>
    </div>
  </section>
  <script type="text/javascript" src="../../scripts/learn.js"></script>
  <script src="../../scripts/prism.js"></script>
  <script type="text/javascript">
    setIntialTab('hmac');
  </script>
</body>
</html>
